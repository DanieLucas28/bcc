bg.figure = "white",
cex = 1,
font.stats = 1,
cex.stats = 0.9,
add.stats = TRUE,
chart.all = TRUE,
fill = TRUE)
bcc(Montgomery2005$PD, Montgomery2005$TODA, type="beta", confidence.level = 0.9)
library(readxl)
Montgomery2005 <- read_excel("C:/Users/danie/Desktop/Beta Charts - r/Montgomery2005.xlsx")
View(Montgomery2005)
bcc(Montgomery2005$PD, Montgomery2005$TODA, type="beta", confidence.level = 0.9)
bcc <- function(data, type = c("beta","beta.prop"), sizes, center, std.dev, limits, data.name, labels, newdata, newsizes, newdata.name, newlabels, nsigmas = 3, confidence.level, rules = shewhart.rules, plot = TRUE, ...)
{
call <- match.call()
if (missing(data))
stop("'data' argument is not specified")
if(identical(type, eval(formals(bcc)$type)))
{ type <- as.character(type)[1]
warning("chart 'type' not specified, assuming \"", type, "\"",
immediate. = TRUE) }
if(!exists(paste("stats.", type, sep = ""), mode="function") |
!exists(paste("sd.", type, sep = ""), mode="function") |
!exists(paste("limits.", type, sep = ""), mode="function"))
stop(paste("invalid", type, "control chart. See help(bcc) "))
if (missing(data.name))
data.name <- deparse(substitute(data))
data <- data.matrix(data)
if (missing(sizes))
{ if (any(type==c("p", "np", "u")))
stop(paste("sample 'sizes' must be given for a", type, "Chart"))
else
sizes <- apply(data, 1, function(x) sum(!is.na(x)))  }
else
{ if (length(sizes)==1)
sizes <- rep(sizes, nrow(data))
else if (length(sizes) != nrow(data))
stop("sizes length doesn't match with data") }
if (missing(labels))
{ if (is.null(rownames(data))) labels <- 1:nrow(data)
else                         labels <- rownames(data) }
stats <- paste("stats.", type, sep = "")
if (!exists(stats, mode="function"))
stop(paste("function", stats, "is not defined"))
stats <- do.call(stats, list(data, sizes))
statistics <- stats$statistics
if (missing(center)) center <- stats$center
sd <- paste("sd.", type, sep = "")
if (!exists(sd, mode="function"))
stop(paste("function", sd, "is not defined!"))
missing.std.dev <- missing(std.dev)
if (missing.std.dev)
{ std.dev <- NULL
std.dev <- switch(type,
"xbar" = { if(any(sizes > 25)) "RMSDF"
else                "UWAVE-R" },
"xbar.one" = "MR",
"R" = "UWAVE-R",
"S" = "UWAVE-SD",
NULL)
std.dev <- do.call(sd, list(data, sizes, std.dev)) }
else
{ if (is.character(std.dev))
{ std.dev <- do.call(sd, list(data, sizes, std.dev)) }
else
{ if (!is.numeric(std.dev))
stop("if provided the argument 'std.dev' must be a method available or a numerical value. See help(bcc).")  }
}
names(statistics) <-  rownames(data) <-  labels
names(dimnames(data)) <- list("Group", "Samples")
object <- list(call = call, type = type,
data.name = data.name, data = data,
statistics = statistics, sizes = sizes,
center = center, std.dev = std.dev)
# check for new data provided and update object
if (!missing(newdata))
{   if (missing(newdata.name))
{newdata.name <- deparse(substitute(newdata))}
newdata <- data.matrix(newdata)
if (missing(newsizes))
{ if (any(type==c("p", "np", "u")))
stop(paste("sample sizes must be given for a", type, "Chart"))
else
newsizes <- apply(newdata, 1, function(x) sum(!is.na(x))) }
else
{ if (length(newsizes)==1)
newsizes <- rep(newsizes, nrow(newdata))
else if (length(newsizes) != nrow(newdata))
stop("newsizes length doesn't match with newdata") }
stats <- paste("stats.", type, sep = "")
if (!exists(stats, mode="function"))
stop(paste("function", stats, "is not defined"))
newstats <- do.call(stats, list(newdata, newsizes))$statistics
if (missing(newlabels))
{ if (is.null(rownames(newdata)))
{ start <- length(statistics)
newlabels <- seq(start+1, start+length(newstats)) }
else
{ newlabels <- rownames(newdata) }
}
names(newstats) <- newlabels
object$newstats <- newstats
object$newdata  <- newdata
object$newsizes <- newsizes
object$newdata.name <- newdata.name
statistics <- c(statistics, newstats)
sizes <- c(sizes, newsizes)
}
conf <- nsigmas
if (!missing(confidence.level))
conf <- confidence.level
if (conf >= 1)
{ object$nsigmas <- conf }
else
if (conf > 0 & conf < 1)
{ object$confidence.level <- conf }
# get control limits
if (missing(limits))
{ limits <- paste("limits.", type, sep = "")
if (!exists(limits, mode="function"))
stop(paste("function", limits, "is not defined"))
limits <- do.call(limits, list(center = center, std.dev = std.dev,
sizes = sizes, conf = conf))
}
else
{ if (!missing.std.dev)
warning("'std.dev' is not used when limits is given")
if (!is.numeric(limits))
stop("'limits' must be a vector of length 2 or a 2-columns matrix")
limits <- matrix(limits, ncol = 2)
dimnames(limits) <- list(rep("",nrow(limits)), c("LCL ", "UCL"))
}
lcl <- limits[,1]
ucl <- limits[,2]
object$limits <- limits
if (is.function(rules)) violations <- rules(object)
else                    violations <- NULL
object$violations <- violations
class(object) <- "bcc"
if(plot) plot(object, ...)
return(object)
}
print.bcc <- function(x, ...) str(x,1)
summary.bcc <- function(object, digits =  getOption("digits"), ...)
{
#object <- x   # Argh.  Really want to use 'object' anyway
cat("\nCall:\n",deparse(object$call),"\n\n",sep="")
data.name <- object$data.name
type <- object$type
cat(paste(type, "chart for", data.name, "\n"))
statistics <- object$statistics
cat("\nSummary of group statistics:\n")
print(summary(statistics), digits = digits, ...)
sizes <- object$sizes
if(length(unique(sizes))==1)
sizes <- sizes[1]
if(length(sizes) == 1)
cat("\nGroup sample size: ", format(sizes))
else {
cat("\nSummary of group sample sizes: ")
tab <- table(sizes)
print(matrix(c(as.numeric(names(tab)), tab),
ncol = length(tab), byrow = TRUE,
dimnames = list(c("  sizes", "  counts"),
character(length(tab)))),
digits = digits, ...)
}
cat("\nNumber of groups: ", length(statistics))
center <- object$center
if(length(center) == 1)
{ cat("\nCenter of group statistics: ", format(center, digits = digits)) }
else
{ out <- paste(format(center, digits = digits))
out <- out[which(cumsum(nchar(out)+1) < getOption("width")-40)]
out <- paste0(paste(out, collapse = " "), " ...")
cat("\nCenter of group statistics: ", out, sep = "")
}
sd <- object$std.dev
if(length(sd) == 1)
{ cat("\nStandard deviation: ", format(sd, digits = digits), "\n") }
else
{ out <- paste(format(sd, digits = digits))
out <- out[which(cumsum(nchar(out)+1) < getOption("width")-40)]
out <- paste0(paste(out, collapse = " "), " ...")
cat("\nStandard deviation: ", out, "\n", sep = "")
}
newdata.name <- object$newdata.name
newstats <- object$newstats
if (!is.null(newstats))
{ cat(paste("\nSummary of group statistics in ",
newdata.name, ":\n", sep = ""))
print(summary(newstats), digits = digits, ...)
newsizes <- object$newsizes
if (length(unique(newsizes)) == 1)
newsizes <- newsizes[1]
if (length(newsizes) == 1)
cat("\nGroup sample size: ", format(newsizes))
else
{ cat("\nSummary of group sample sizes:\n")
new.tab <- table(newsizes)
print(matrix(c(as.numeric(names(new.tab)), new.tab),
ncol = length(new.tab), byrow = TRUE,
dimnames = list(c("  sizes", "  counts"),
character(length(new.tab)))),
digits = digits, ...)
}
cat("\nNumber of groups: ", length(newstats), "\n")
}
limits <- object$limits
if (!is.null(limits))
{ cat("\nControl limits:\n")
.printShortMatrix(limits, digits = digits, ...) }
invisible()
}
plot.bcc <- function(x, add.stats = TRUE, chart.all = TRUE,
label.limits = c("LCL ", "UCL"),
title, xlab, ylab, ylim, axes.las = 0,
digits =  getOption("digits"),
restore.par = TRUE, ...)
{
object <- x  # Argh.  Really want to use 'object' anyway
if ((missing(object)) | (!inherits(object, "bcc")))
stop("an object of class `bcc' is required")
# collect info from object
type <- object$type
std.dev <- object$std.dev
data.name <- object$data.name
center <- object$center
stats <- object$statistics
limits <- object$limits
lcl <- limits[,1]
ucl <- limits[,2]
newstats <- object$newstats
newdata.name <- object$newdata.name
violations <- object$violations
if(chart.all)
{ statistics <- c(stats, newstats)
indices <- 1:length(statistics) }
else
{ if(is.null(newstats))
{ statistics <- stats
indices <- 1:length(statistics) }
else
{ statistics <- newstats
indices <- seq(length(stats)+1, length(stats)+length(newstats)) }
}
if (missing(title))
{ if (is.null(newstats))
main.title <- paste(type, "Chart\nfor", data.name)
else if (chart.all)
main.title <- paste(type, "Chart\nfor", data.name,
"and", newdata.name)
else main.title <- paste(type, "Chart\nfor", newdata.name)
}
else main.title <- paste(title)
oldpar <- par(no.readonly = TRUE)
if(restore.par) on.exit(par(oldpar))
mar <- pmax(oldpar$mar, c(4.1,4.1,3.1,2.1))
par(bg  = bcc.options("bg.margin"),
cex = oldpar$cex * bcc.options("cex"),
mar = if(add.stats) pmax(mar, c(7.6,0,0,0)) else mar)
# plot Shewhart chart
plot(indices, statistics, type="n",
ylim = if(!missing(ylim)) ylim
else range(statistics, limits, center),
ylab = if(missing(ylab)) "Group summary statistics" else ylab,
xlab = if(missing(xlab)) "Group" else xlab,
axes = FALSE)
rect(par("usr")[1], par("usr")[3], par("usr")[2], par("usr")[4],
col = bcc.options("bg.figure"))
axis(1, at = indices, las = axes.las,
labels = if(is.null(names(statistics)))
as.character(indices) else names(statistics))
axis(2, las = axes.las)
box()
top.line <- par("mar")[3]-length(capture.output(cat(main.title)))
top.line <- top.line - if(chart.all & (!is.null(newstats))) 0.1 else 0.5
mtext(main.title, side = 3, line = top.line,
font = par("font.main"),
cex  = bcc.options("cex"),
col  = par("col.main"))
lines(indices, statistics, type = "b", pch=20)
if(length(center) == 1)
abline(h = center)
else lines(indices, center[indices], type="s")
if(length(lcl) == 1)
{ abline(h = lcl, lty = 2)
abline(h = ucl, lty = 2) }
else
{ lines(indices, lcl[indices], type="s", lty = 2)
lines(indices, ucl[indices], type="s", lty = 2) }
mtext(label.limits, side = 4, at = c(rev(lcl)[1], rev(ucl)[1]),
las = 1, line = 0.1, col = gray(0.3), cex = par("cex"))
mtext("CL", side = 4, at = rev(center)[1],
las = 1, line = 0.1, col = gray(0.3), cex = par("cex"))
if(is.null(bcc.options("violating.runs")))
stop(".bcc.options$violating.runs undefined. See help(bcc.options).")
if(length(violations$violating.runs))
{ v <- violations$violating.runs
if(!chart.all & !is.null(newstats))
{ v <- v - length(stats)
v <- v[v>0] }
points(indices[v], statistics[v],
col = bcc.options("violating.runs")$col,
pch = bcc.options("violating.runs")$pch)
}
if(is.null(bcc.options("beyond.limits")))
stop(".bcc.options$beyond.limits undefined. See help(bcc.options).")
if(length(violations$beyond.limits))
{ v <- violations$beyond.limits
if(!chart.all & !is.null(newstats))
{ v <- v - length(stats)
v <- v[v>0] }
points(indices[v], statistics[v],
col = bcc.options("beyond.limits")$col,
pch = bcc.options("beyond.limits")$pch)
}
if(chart.all & (!is.null(newstats)))
{ len.obj.stats <- length(object$statistics)
len.new.stats <- length(statistics) - len.obj.stats
abline(v = len.obj.stats + 0.5, lty = 3)
mtext(# paste("Calibration data in", data.name),
"Calibration data", cex = par("cex")*0.8,
at = len.obj.stats/2, line = 0, adj = 0.5)
mtext(# paste("New data in", object$newdata.name),
"New data", cex = par("cex")*0.8,
at = len.obj.stats + len.new.stats/2, line = 0, adj = 0.5)
}
if(add.stats)
{
# computes the x margins of the figure region
plt <- par()$plt; usr <- par()$usr
px <- diff(usr[1:2])/diff(plt[1:2])
xfig <- c(usr[1]-px*plt[1], usr[2]+px*(1-plt[2]))
at.col <- xfig[1] + diff(xfig[1:2])*c(0.10, 0.40, 0.65)
top.line <- 4.5
# write info at bottom
mtext(paste("Number of groups = ", length(statistics), sep = ""),
side = 1, line = top.line, adj = 0, at = at.col[1],
font = bcc.options("font.stats"),
cex = par("cex")*bcc.options("cex.stats"))
center <- object$center
if(length(center) == 1)
{ mtext(paste("Center = ", signif(center[1], digits), sep = ""),
side = 1, line = top.line+1, adj = 0, at = at.col[1],
font = bcc.options("font.stats"),
cex = par("cex")*bcc.options("cex.stats"))
}
else
{ mtext("Center is variable",
side = 1, line = top.line+1, adj = 0, at = at.col[1],
font = bcc.options("font.stats"),
cex = par("cex")*bcc.options("cex.stats"))
}
if(length(std.dev) == 1)
{ mtext(paste("StdDev = ", signif(std.dev, digits), sep = ""),
side = 1, line = top.line+2, adj = 0, at = at.col[1],
font = bcc.options("font.stats"),
cex = par("cex")*bcc.options("cex.stats"))
}
else
{ mtext("StdDev is variable",
side = 1, line = top.line+2, adj = 0, at = at.col[1],
font = bcc.options("font.stats"),
cex = par("cex")*bcc.options("cex.stats"))
}
if(length(unique(lcl)) == 1)
{ mtext(paste("LCL = ", signif(lcl[1], digits), sep = ""),
side = 1, line = top.line+1, adj = 0, at = at.col[2],
font = bcc.options("font.stats"),
cex = par("cex")*bcc.options("cex.stats"))
}
else
{ mtext("LCL is variable",
side = 1, line = top.line+1, adj = 0, at = at.col[2],
font = bcc.options("font.stats"),
cex = par("cex")*bcc.options("cex.stats"))
}
if(length(unique(ucl)) == 1)
{ mtext(paste("UCL = ", signif(ucl[1], digits), sep = ""),
side = 1, line = top.line+2, adj = 0, at = at.col[2],
font = bcc.options("font.stats"),
cex = par("cex")*bcc.options("cex.stats"))
}
else
{ mtext("UCL is variable",
side = 1, line = top.line+2, adj = 0, at = at.col[2],
font = bcc.options("font.stats"),
cex = par("cex")*bcc.options("cex.stats"))
}
if(!is.null(violations))
{ mtext(paste("Number beyond limits =",
length(unique(violations$beyond.limits))),
side = 1, line = top.line+1, adj = 0, at = at.col[3],
font = bcc.options("font.stats"),
cex = par("cex")*bcc.options("cex.stats"))
mtext(paste("Number violating runs =",
length(unique(violations$violating.runs))),
side = 1, line = top.line+2, adj = 0, at = at.col[3],
font = bcc.options("font.stats"),
cex = par("cex")*bcc.options("cex.stats"))
}
}
invisible()
}
#
#  Functions used to compute Shewhart charts statistics
#
.bcc.c4 <- function(n)
{ sqrt(2/(n - 1)) * exp(lgamma(n/2) - lgamma((n - 1)/2)) }
#
# Functions used to signal points out of control
#
shewhart.rules <- function(object, limits = object$limits, run.length = bcc.options("run.length"))
{
# Return a list of cases beyond limits and violating runs
bl <- beyond.limits(object, limits = limits)
vr <- violating.runs(object, run.length = run.length)
list(beyond.limits = bl, violating.runs = vr)
}
beyond.limits <- function(object, limits = object$limits)
{
# Return cases beyond limits
statistics <- c(object$statistics, object$newstats)
lcl <- limits[,1]
ucl <- limits[,2]
index.above.ucl <- seq(along = statistics)[statistics > ucl]
index.below.lcl <- seq(along = statistics)[statistics < lcl]
return(c(index.above.ucl, index.below.lcl))
}
violating.runs <- function(object, run.length = bcc.options("run.length"))
{
# Return indices of points violating runs
if(run.length == 0)
return(numeric())
center <- object$center
statistics <- c(object$statistics, object$newstats)
cl <- object$limits
diffs <- statistics - center
diffs[diffs > 0] <- 1
diffs[diffs < 0] <- -1
runs <- rle(diffs)
vruns <- rep(runs$lengths >= run.length, runs$lengths)
vruns.above <- (vruns & (diffs > 0))
vruns.below <- (vruns & (diffs < 0))
rvruns.above <- rle(vruns.above)
rvruns.below <- rle(vruns.below)
vbeg.above <- cumsum(rvruns.above$lengths)[rvruns.above$values] -
(rvruns.above$lengths - run.length)[rvruns.above$values]
vend.above <- cumsum(rvruns.above$lengths)[rvruns.above$values]
vbeg.below <- cumsum(rvruns.below$lengths)[rvruns.below$values] -
(rvruns.below$lengths - run.length)[rvruns.below$values]
vend.below <- cumsum(rvruns.below$lengths)[rvruns.below$values]
violators <- numeric()
if (length(vbeg.above))
{ for (i in 1:length(vbeg.above))
violators <- c(violators, vbeg.above[i]:vend.above[i]) }
if (length(vbeg.below))
{ for (i in 1:length(vbeg.below))
violators <- c(violators, vbeg.below[i]:vend.below[i]) }
return(violators)
}
bcc.options <- function(...)
{
current <- .bcc.options
if(nargs() == 0) return(current)
#  if(is.character(...))
#       temp <- eval(parse(text = paste(c("list(", ..., ")"))))
#  else temp <- list(...)
temp <- list(...)
if(length(temp) == 1 && is.null(names(temp)))
{ arg <- temp[[1]]
switch(mode(arg),
list = temp <- arg,
character = return(.bcc.options[[arg]]),
stop(paste("invalid argument:", sQuote(arg)))) }
if(length(temp) == 0) return(current)
name <- names(temp)
if(is.null(name)) stop("options must be given by name")
changed <- current[name]
current[name] <- temp
env <- if(sys.parent() == 0) asNamespace("bcc")
else                  parent.frame()
assign(".bcc.options", current, envir = env)
invisible(current)
}
# TODO: reorganize...
".bcc.options" <- list(
exp.R.unscaled = c(NA, 1.128, 1.693, 2.059, 2.326, 2.534, 2.704, 2.847, 2.970, 3.078, 3.173, 3.258, 3.336, 3.407, 3.472, 3.532, 3.588, 3.640, 3.689, 3.735, 3.778, 3.819, 3.858, 3.895, 3.931),
se.R.unscaled = c(NA, 0.8525033, 0.8883697, 0.8798108, 0.8640855, 0.8480442, 0.8332108, 0.8198378, 0.8078413, 0.7970584, 0.7873230, 0.7784873, 0.7704257, 0.7630330, 0.7562217, 0.7499188, 0.7440627, 0.7386021, 0.7334929, 0.7286980, 0.7241851, 0.7199267, 0.7158987, 0.7120802, 0.7084528, 0.7050004, 0.7017086, 0.6985648, 0.6955576, 0.6926770, 0.6899137, 0.6872596, 0.6847074, 0.6822502, 0.6798821, 0.6775973, 0.6753910, 0.6732584, 0.6711952, 0.6691976, 0.6672619, 0.6653848, 0.6635632, 0.6617943, 0.6600754, 0.6584041, 0.6567780, 0.6551950, 0.6536532, 0.6521506),
# TODO: remove
beyond.limits = list(pch=19, col="red"),
violating.runs = list(pch=19, col="orange"),
run.length = 7,
# TODO: remove
shr = list(col = c("#F03B20", "#FEB24C"),
pch = c(19, 20),
run.length = 7),
rules = list(col = c("#F03B20", "#FD8D3C", "#FEB24C", "#FED976"),
pch = c(19, 15, 17, 20)),
zones = list(fill = "#81a1c1",
lty = c(2,2,2),
col = grey(c(0.1, 0.4, 0.7))),
bg.margin = grey(0.915),
bg.figure = "white",
cex = 1,
font.stats = 1,
cex.stats = 0.9,
add.stats = TRUE,
chart.all = TRUE,
fill = TRUE)
bcc(Montgomery2005$PD, Montgomery2005$TODA, type="beta", confidence.level = 0.9)
