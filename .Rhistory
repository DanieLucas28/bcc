limits.1sigma[indices[length(indices)],2])
xp1 <- rep(x1, each=2)[-1]
xp2 <- rep(x2, each=2)[-1]
yp1 <- rep(y1, each=2)[-2*length(y1)]
yp2 <- rep(y2, each=2)[-2*length(y2)]
polygon(c(xp1,rev(xp2)), c(yp1,rev(yp2)),
border = FALSE,
col = adjustcolor(qcc.options("zones")$fill, alpha.f = 0.1))
}
} else
{
if(nrow(limits.1sigma) == 1)
{
abline(h = limits.1sigma,
lty = qcc.options("zones")$lty[3],
col = qcc.options("zones")$col[3])
} else
{
x1 <- x2 <- c(indices, indices[length(indices)]+1)-0.5
y1 <- c(limits.1sigma[indices,1],
limits.1sigma[indices[length(indices)],1])
y2 <- c(limits.1sigma[indices,2],
limits.1sigma[indices[length(indices)],2])
lines(x1, y1, type="s",
lty = qcc.options("zones")$lty[3],
col = qcc.options("zones")$col[3])
lines(x2, y2, type="s",
lty = qcc.options("zones")$lty[3],
col = qcc.options("zones")$col[3])
}
}
}
# draw center line
if(length(center) == 1)
abline(h = center, col = qcc.options("zones")$col[1])
else
lines(indices, center[indices], type="s",
col = qcc.options("zones")$col[1])
# draw lines & points
lines(indices, statistics, type = "b", pch=NA)
col <- rep(palette()[1], length(indices))
pch <- rep(20, length(indices))
if(!is.null(violations))
{
for(j in 1:4)
{
i <- (indices %in% which(violations==j))
col[i] <- qcc.options("rules")$col[j]
pch[i] <- qcc.options("rules")$pch[j]
}
}
points(indices, statistics, col = col, pch = pch)
if(chart.all & (!is.null(newstats)))
{
len.obj.stats <- length(object$statistics)
len.new.stats <- length(statistics) - len.obj.stats
abline(v = len.obj.stats + 0.5, lty = 3)
mtext("Calibration data", cex = par("cex")*0.8,
at = len.obj.stats/2, line = 0, adj = 0.5)
mtext("New data", cex = par("cex")*0.8,
at = len.obj.stats + len.new.stats/2, line = 0, adj = 0.5)
}
if(add.stats)
{
at <- c(0.10,0.40,0.65)
# seq(par("plt")[1], par("plt")[2], length.out = 4)[-4]
# write info at bottom
mtext(paste("Number of groups = ", length(statistics), sep = ""),
side = 1, outer = TRUE, line = 0, adj = 0, at = at[1],
font = qcc.options("font.stats"),
cex = par("cex")*qcc.options("cex.stats"))
center <- object$center
if(length(center) == 1)
{ mtext(paste("Center = ", signif(center[1], digits), sep = ""),
side = 1, outer = TRUE, line = 1*cex.stats, adj = 0, at = at[1],
font = qcc.options("font.stats"),
cex = par("cex")*qcc.options("cex.stats"))
} else
{ mtext("Center is variable",
side = 1, outer = TRUE, line = 1*cex.stats, adj = 0, at = at[1],
font = qcc.options("font.stats"),
cex = par("cex")*qcc.options("cex.stats"))
}
if(length(std.dev) == 1)
{ mtext(paste("StdDev = ", signif(std.dev, digits), sep = ""),
side = 1, outer = TRUE, line = 2*cex.stats, adj = 0, at = at[1],
font = qcc.options("font.stats"),
cex = par("cex")*qcc.options("cex.stats"))
} else
{ mtext("StdDev is variable",
side = 1, outer = TRUE, line = 2*cex.stats, adj = 0, at = at[1],
font = qcc.options("font.stats"),
cex = par("cex")*qcc.options("cex.stats"))
}
if(length(unique(lcl)) == 1)
{ mtext(paste("LCL = ", signif(lcl[1], digits), sep = ""),
side = 1, outer = TRUE, line = 1*cex.stats, adj = 0, at = at[2],
font = qcc.options("font.stats"),
cex = par("cex")*qcc.options("cex.stats"))
}
else
{ mtext("LCL is variable",
side = 1, outer = TRUE, line = 1*cex.stats, adj = 0, at = at[2],
font = qcc.options("font.stats"),
cex = par("cex")*qcc.options("cex.stats"))
}
if(length(unique(ucl)) == 1)
{ mtext(paste("UCL = ", signif(ucl[1], digits), sep = ""),
side = 1, outer = TRUE, line = 2*cex.stats, adj = 0, at = at[2],
font = qcc.options("font.stats"),
cex = par("cex")*qcc.options("cex.stats"))
}
else
{ mtext("UCL is variable",
side = 1, outer = TRUE, line = 2*cex.stats, adj = 0, at = at[2],
font = qcc.options("font.stats"),
cex = par("cex")*qcc.options("cex.stats"))
}
if(!is.null(violations))
{ mtext(paste("Number beyond limits =",
sum(violations==1, na.rm=TRUE)),
side = 1, outer = TRUE, line = 1*cex.stats, adj = 0, at = at[3],
font = qcc.options("font.stats"),
cex = par("cex")*qcc.options("cex.stats"))
mtext(paste("Number violating runs =",
sum(violations > 1, na.rm=TRUE)),
side = 1, outer = TRUE, line = 2*cex.stats, adj = 0, at = at[3],
font = qcc.options("font.stats"),
cex = par("cex")*qcc.options("cex.stats"))
}
}
invisible()
}
#
#  Functions used to compute Shewhart charts statistics
#
qcc.c4 <- function(n)
{ sqrt(2/(n - 1)) * exp(lgamma(n/2) - lgamma((n - 1)/2)) }
#beta charts
sd.beta.prop <- function(data, sizes, std.dev)
{
data <- as.vector(data)
sd <- sqrt(var(data))
return(sd)
}
sd.beta <- function(data, sizes, ...)
{
data <- as.vector(data)
sizes <- as.vector(sizes)
pbar <- sum(data)/sum(sizes)
std.dev <- sqrt(pbar * (1 - pbar))
return(std.dev)
}
stats.beta.prop <- function(data, sizes)
{
statistics <- as.vector(data)
center <- mean(statistics)
list(statistics = statistics, center = center)
}
stats.beta <- function(data, sizes)
{
data <- as.vector(data)
sizes<- as.vector(sizes)
pbar <- sum(data)/sum(sizes)
list(statistics = data/sizes, center = pbar)
}
limits.beta.prop <- function(center, std.dev, sizes, conf, ...)
{
if (conf >= 1)
{
show("without application, determine another value for confidence.level")
}
else
{ if (conf > 0 & conf < 1)
{
probucl<-0.99865
problcl<-0.00135
alfa<-center*(((center*(1-center))/(std.dev^2))-1)
beta<-(1-center)*(((center*(1-center))/(std.dev^2))-1)
lcl <-qbeta(problcl, alfa, beta)
ucl <-qbeta(probucl, alfa, beta)
}
else stop("invalid conf argument. See help.")
}
limits <- matrix(c(lcl, ucl), ncol = 2)
rownames(limits) <- rep("", length = nrow(limits))
colnames(limits) <- c("LCL", "UCL")
return(limits)
}
limits.beta <- function(center, std.dev, sizes, conf, ...)
{
probucl<-0.99865
problcl<-0.00135
sizes <- as.vector(sizes)
n<-mean(sizes)
alfa<-center*(((center*(1-center))/((center*(1-center))/n))-1) #=B5*(((B5*(1-B5))/((B5*(1-B5))/B4))-1)
beta<-(1-center)*(((center*(1-center))/((center*(1-center))/n))-1) #=(1-B5)*(((B5*(1-B5))/((B5*(1-B5))/B4))-1)
if (conf >= 1)
{
show("without application, determine another value for confidence.level")
}
else
{ if (conf > 0 & conf < 1)
{
lcl <-qbeta(problcl, alfa, beta)
ucl <-qbeta(probucl, alfa, beta)
}
else stop("invalid conf argument. See help.")
}
limits <- matrix(c(lcl, ucl), ncol = 2)
rownames(limits) <- rep("", length = nrow(limits))
colnames(limits) <- c("LCL", "UCL")
return(limits)
}
bcc(Montgomery2005$PD, sizes = Montgomery2005$TODA, type = "beta", confidence.level = 0.9)
library(readxl)
Database_MDB_1_ <- read_excel("C:/Users/danie/Desktop/Beta Charts - r/Database MDB (1).xlsx",
sheet = "PC X PA")
View(Database_MDB_1_)
bcc(Database_MDB_1_$razao, type = "beta.prop", confidence.level = 0.9)
devtools::check()
devtools::check()
devtools::check()
devtools::check()
library("bcc")
library(readxl)
Montgomery2005 <- read_excel("C:/Users/danie/Desktop/Beta Charts - r/Montgomery2005.xlsx")
View(Montgomery2005)
bcc(Database_MDB_1_$razao, type = "beta.prop", confidence.level = 0.9)
library(readxl)
Database_MDB_1_ <- read_excel("C:/Users/danie/Desktop/Beta Charts - r/Database MDB (1).xlsx",
sheet = "PC X PA")
View(Database_MDB_1_)
bcc(Database_MDB_1_$razao, type = "beta.prop", confidence.level = 0.9)
bcc(Montgomery2005$PD, sizes = Montgomery2005$TODA, type = "beta", confidence.level = 0.9)
library(readxl)
Montgomery2005 <- read_excel("C:/Users/danie/Desktop/Beta Charts - r/Montgomery2005.xlsx")
View(Montgomery2005)
matrix(data = sample(1:50, size = 10, replace = FALSE), nrow = 1, ncol = 1)
x<-sample(1:50, size = 10)
matrix(data = sample(x, size = 10, replace = FALSE), nrow = 1, ncol = 1)
matrix(data = x, nrow = 1, ncol = 1)
matrix(data = x, nrow = 1, ncol = 1, byrow = FALSE)
matrix(data = x, nrow = 1, ncol = 1, byrow = FALSE)
matrix(data = x, nrow = 1, ncol = 1, byrow = TRUE)
library(readxl)
Pasta1 <- read_excel("C:/Users/danie/Desktop/Pasta1.xlsx")
View(Pasta1)
View(Pasta1)
library(readxl)
Pasta1 <- read_excel("C:/Users/danie/Desktop/Pasta1.xlsx",
sheet = "Planilha2")
View(Pasta1)
library(readxl)
Drapper1998 <- read_excel("C:/Users/danie/Desktop/Beta Charts - r/Drapper1998.xlsx")
View(Drapper1998)
View(Montgomery2005)
library(readxl)
Database_MDB_1_ <- read_excel("C:/Users/danie/Desktop/Beta Charts - r/Database MDB (1).xlsx",
sheet = "PC X PA")
View(Database_MDB_1_)
library("bcc", lib.loc="F:/Program Files/R/R-3.5.1/library")
library(bcc)
install.packages(qcc)
install.packages("qcc")
library("bcc", lib.loc="F:/Program Files/R/R-3.5.1/library")
bcc(Montgomery2005, data = Montgomery2005$PD, sizes = Montgomery2005$TODA, type = "beta")
bcc(Montgomery2005, data = Montgomery2005$PD, sizes = Montgomery2005$TODA, type = "beta", confidence.level = 0.9)
devtools::install_github("danielucas28/bcc")
library("qcc", lib.loc="F:/Program Files/R/R-3.5.1/library")
remove.packages("qcc")
bcc(Montgomery2005, data = Montgomery2005$PD, sizes = Montgomery2005$TODA, type = "beta", confidence.level = 0.9)
library("bcc", lib.loc="F:/Program Files/R/R-3.5.1/library")
bcc(Montgomery2005, data = Montgomery2005$PD, sizes = Montgomery2005$TODA, type = "beta", confidence.level = 0.9)
library("bcc", lib.loc="F:/Program Files/R/R-3.5.1/library")
bcc(Montgomery2005, data = Montgomery2005$PD, sizes = Montgomery2005$TODA, type = "beta", confidence.level = 0.9)
library(readxl)
Montgomery2005 <- read_excel("C:/Users/danie/Desktop/Beta Charts - r/Montgomery2005.xlsx")
View(Montgomery2005)
bcc(Montgomery2005, data = Montgomery2005$PD, sizes = Montgomery2005$TODA, type = "beta", confidence.level = 0.9)
#' Beta Control Charts
#'
#' p-Charts and np-Charts are commonly used in monitoring variables of the fraction type and these charts assume that the monitored variables are binomially distributed. In this paper we propose a new control chart called Beta Charts, for monitoring fraction data (p). The Beta Chart presents the control limits based on the Beta probability distribution. It was applied for monitoring the variables in three real studies, and it was compared to the control limits with three schemes. The comparative analysis showed that: (i) Beta approximation to the Binomial distribution was more appropriate with values confined in the [0, 1]- interval; and (ii) the charts proposed were more sensitive to the average run length (ARL), in both in-control and out-of-control processes monitoring. The Beta Charts outperform the control charts analyzed for monitoring fraction data.
#'
#'
#'
#' @export bcc
#' @import qcc
#' @reference SANT'ANNA, Ângelo M. O; CATEN, Carla Schwengberten. Beta control charts for monitoring fraction data. Expert Systems With Applications, p. 10236-10243. 1 set. 2012.
bcc<-function(data, type = c("beta", "beta.prop"),
sizes, center, std.dev, limits, data.name, labels, newdata, newsizes,
newdata.name, newlabels, nsigmas = 3, confidence.level, rules = shewhart.rules,
plot = TRUE, ...){
if (bcc == "beta"){
qcc(data = data, sizes = sizes, type = "beta", confidence.level = 0.9)
}
if (type == "beta.prop"){
qcc(data = data, type= "beta.prop", confidence.level = 0.9)
}
}
bcc(type="beta")
#' Beta Control Charts
#'
#' p-Charts and np-Charts are commonly used in monitoring variables of the fraction type and these charts assume that the monitored variables are binomially distributed. In this paper we propose a new control chart called Beta Charts, for monitoring fraction data (p). The Beta Chart presents the control limits based on the Beta probability distribution. It was applied for monitoring the variables in three real studies, and it was compared to the control limits with three schemes. The comparative analysis showed that: (i) Beta approximation to the Binomial distribution was more appropriate with values confined in the [0, 1]- interval; and (ii) the charts proposed were more sensitive to the average run length (ARL), in both in-control and out-of-control processes monitoring. The Beta Charts outperform the control charts analyzed for monitoring fraction data.
#'
#'
#'
#' @export bcc
#' @import qcc
#' @reference SANT'ANNA, Ângelo M. O; CATEN, Carla Schwengberten. Beta control charts for monitoring fraction data. Expert Systems With Applications, p. 10236-10243. 1 set. 2012.
bcc<-function(data, type = c("1", "2"),
sizes, center, std.dev, limits, data.name, labels, newdata, newsizes,
newdata.name, newlabels, nsigmas = 3, confidence.level, rules = shewhart.rules,
plot = TRUE, ...){
res <- type
if (type == 1){
qcc(data = data, type = "beta",
sizes = sizes, center = center, std.dev = std.dev, limits = limits, data.name = data.name, labels = labels, newdata = newdata, newsizes = newsizes,
newdata.name = newdata.name, newlabels = newlabels, nsigmas = 3, confidence.level = confidence.level, rules = shewhart.rules,
plot = TRUE, ...)
}
if (type == 2){
qcc(data = data, type = "beta.prop",
sizes = sizes, center = center, std.dev = std.dev, limits = limits, data.name = data.name, labels = labels, newdata = newdata, newsizes = newsizes,
newdata.name = newdata.name, newlabels = newlabels, nsigmas = 3, confidence.level = confidence.level, rules = shewhart.rules,
plot = TRUE, ...)
}
}
#' stats.beta
#'
#' modified qcc functions
#'
#'
#'
#' @export stats.beta
stats.beta <- function(data, sizes)
{
data <- as.vector(data)
sizes<- as.vector(sizes)
pbar <- sum(data)/sum(sizes)
list(statistics = data/sizes, center = pbar)
}
#' stats.beta.prop
#'
#' modified qcc functions
#'
#'
#'
#' @export stats.beta.prop
stats.beta.prop <- function(data, sizes)
{
statistics <- as.vector(data)
center <- mean(statistics)
list(statistics = statistics, center = center)
}
#' sd.beta
#'
#' modified qcc functions
#'
#'
#'
#' @export sd.beta
sd.beta <- function(data, sizes, ...)
{
data <- as.vector(data)
sizes <- as.vector(sizes)
pbar <- sum(data)/sum(sizes)
std.dev <- sqrt(pbar * (1 - pbar))
return(std.dev)
}
#' sd.beta.prop
#'
#' modified qcc functions
#'
#'
#'
#' @export sd.beta.prop
sd.beta.prop <- function(data, sizes, std.dev)
{
data <- as.vector(data)
sd <- sqrt(var(data))
return(sd)
}
#' limits.beta
#'
#' modified qcc functions
#'
#'
#'
#' @export limits.beta
limits.beta <- function(center, std.dev, sizes, conf)
{
probucl<-0.99865
problcl<-0.00135
sizes <- as.vector(sizes)
n<-mean(sizes)
alfa<-center*(((center*(1-center))/((center*(1-center))/n))-1) #=B5*(((B5*(1-B5))/((B5*(1-B5))/B4))-1)
beta<-(1-center)*(((center*(1-center))/((center*(1-center))/n))-1) #=(1-B5)*(((B5*(1-B5))/((B5*(1-B5))/B4))-1)
if (conf >= 1)
{
show("without application, determine another value for confidence.level")
}
else
{ if (conf > 0 & conf < 1)
{
lcl <-qbeta(problcl, alfa, beta)
ucl <-qbeta(probucl, alfa, beta)
}
else stop("invalid conf argument. See help.")
}
limits <- matrix(c(lcl, ucl), ncol = 2)
rownames(limits) <- rep("", length = nrow(limits))
colnames(limits) <- c("LCL", "UCL")
return(limits)
}
#' limits.beta.prop
#'
#' modified qcc functions
#'
#'
#'
#' @export limits.beta.prop
limits.beta.prop <- function(center, std.dev, sizes, conf, ...)
{
if (conf >= 1)
{
show("without application, determine another value for confidence.level")
}
else
{ if (conf > 0 & conf < 1)
{
probucl<-0.99865
problcl<-0.00135
alfa<-center*(((center*(1-center))/(std.dev^2))-1)
beta<-(1-center)*(((center*(1-center))/(std.dev^2))-1)
lcl <-qbeta(problcl, alfa, beta)
ucl <-qbeta(probucl, alfa, beta)
}
else stop("invalid conf argument. See help.")
}
limits <- matrix(c(lcl, ucl), ncol = 2)
rownames(limits) <- rep("", length = nrow(limits))
colnames(limits) <- c("LCL", "UCL")
return(limits)
}
library(readxl)
Drapper1998 <- read_excel("C:/Users/danie/Desktop/Beta Charts - r/Drapper1998.xlsx")
View(Drapper1998)
bcc(data = Drapper1998$PROP, type = "2")
library(qcc)
bcc(data = Drapper1998$PROP, type = "2")
bcc(data = Drapper1998$PROP, type = "2")
#' Beta Control Charts
#'
#' p-Charts and np-Charts are commonly used in monitoring variables of the fraction type and these charts assume that the monitored variables are binomially distributed. In this paper we propose a new control chart called Beta Charts, for monitoring fraction data (p). The Beta Chart presents the control limits based on the Beta probability distribution. It was applied for monitoring the variables in three real studies, and it was compared to the control limits with three schemes. The comparative analysis showed that: (i) Beta approximation to the Binomial distribution was more appropriate with values confined in the [0, 1]- interval; and (ii) the charts proposed were more sensitive to the average run length (ARL), in both in-control and out-of-control processes monitoring. The Beta Charts outperform the control charts analyzed for monitoring fraction data.
#'
#'
#'
#' @export bcc
#' @import qcc
#' @reference SANT'ANNA, Ângelo M. O; CATEN, Carla Schwengberten. Beta control charts for monitoring fraction data. Expert Systems With Applications, p. 10236-10243. 1 set. 2012.
bcc<-function(data, type = c("1", "2"),
sizes, center, std.dev, limits, data.name, labels, newdata, newsizes,
newdata.name, newlabels, nsigmas = 3, confidence.level=0.9, rules = shewhart.rules,
plot = TRUE, ...){
res <- type
if (type == 1){
qcc(data = data, type = "beta",
sizes = sizes, center = center, std.dev = std.dev, limits = limits, data.name = data.name, labels = labels, newdata = newdata, newsizes = newsizes,
newdata.name = newdata.name, newlabels = newlabels, nsigmas = 3, confidence.level = confidence.level, rules = shewhart.rules,
plot = TRUE, ...)
}
if (type == 2){
qcc(data = data, type = "beta.prop",
center = center, std.dev = std.dev, limits = limits, data.name = data.name, labels = labels, newdata = newdata, newsizes = newsizes,
newdata.name = newdata.name, newlabels = newlabels, nsigmas = 3, confidence.level = confidence.level, rules = shewhart.rules,
plot = TRUE, ...)
}
}
bcc(data = Drapper1998$PROP, type = "2")
bcc(data = Drapper1998$PROP, type = "2", data.name = "teste mudar nome")
bcc(data = Drapper1998$PROP, type = "2", data.name = Drapper1998)
bcc(data = Drapper1998$PROP, type = "2", data.name = Drapper1998$PROP)
bcc(data = Drapper1998$PROP, type = "2", data.name = "data")
bcc(data = Drapper1998$PROP, type = "2")
bcc(data = Drapper1998$PROP, type = "2")
bcc(data = Drapper1998$PROP, type = "2", labels = "teste")
devtools::build()
devtools::check()
View(limits.beta)
devtools::build()
devtools::check()
bcc<-function(data, type = c("1", "2"),
sizes, center, std.dev, limits, data.name, labels, newdata, newsizes,
newdata.name, newlabels, nsigmas = 3, confidence.level=0.9, rules = shewhart.rules,
plot = TRUE, ...){
res <- type
if (type == 1){
qcc(data = data, type = "beta",
sizes = sizes, center = center, std.dev = std.dev, limits = limits, data.name = data.name, labels = labels, newdata = newdata, newsizes = newsizes,
newdata.name = newdata.name, newlabels = newlabels, nsigmas = 3, confidence.level = confidence.level, rules = shewhart.rules,
plot = TRUE, ...)
}
if (type == 2){
qcc(data = data, type = "beta.prop",
center = center, std.dev = std.dev, limits = limits, data.name = data.name, labels = labels, newdata = newdata, newsizes = newsizes,
newdata.name = newdata.name, newlabels = newlabels, nsigmas = 3, confidence.level = confidence.level, rules = shewhart.rules,
plot = TRUE, ...)
}
}
devtools::build()
devtools::check()
